stages:
  - check
  - build
  - test
  - deploy
  - teardown

variables:
  PIPELINE_UTILS: "pipeline-utilities"

# Runs a pipeline that builds a base of all 3 images on fresh merge requests.
child-build-pipeline:
  stage: check
  trigger:
    include:
      - local: $PIPELINE_UTILS/build-base-images.yml
    strategy: depend
  rules:
    - if: $CI_MERGE_REQUEST_ID
  allow_failure: true

# Template for all build jobs
.build_image_template: &build_image_template
  stage: build
  image: docker:latest
  variables:
    REACT_FOLDER: "frontend"
    DOTNET_FOLDER: "backend"
    REGISTRY_PATH: "$CI_REGISTRY/chas-challenge-2025/group-13/Plan-IT"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - export CI_COMMIT_REF_NAME=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - if [[ $CI_COMMIT_REF_NAME = $CI_DEFAULT_BRANCH ]]; then DOCKER_TAG=latest; else DOCKER_TAG=$CI_COMMIT_REF_NAME; fi

# Generate and publish a new Dockerimage of our .NET-application
# Runs on any change in back-end folder
build-dotnet-image:
  <<: *build_image_template
  script:
    - cp "$PIPELINE_UTILS"/Dockerfile-dotnet "$DOTNET_FOLDER"
    - cp "$REACT_FOLDER"/frontend.esproj "$DOTNET_FOLDER"
    - cd "$DOTNET_FOLDER"
    - export IMAGE_NAME="$CI_REGISTRY_IMAGE/dotnet:$DOCKER_TAG"
    - echo "Building $IMAGE_NAME"
    - docker buildx build --cache-from="$IMAGE_NAME" -t "$IMAGE_NAME" --push -f Dockerfile-dotnet .
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_ID
      changes:
        - $DOTNET_FOLDER/**/*
        - $REACT_FOLDER/frontend.esproj

# Generate and publish a new Dockerimage of our React-application
# Runs on any change in front-end folder
build-react-image:
  <<: *build_image_template
  script:
    - cp "$PIPELINE_UTILS"/vite.config.docker.js "$REACT_FOLDER"
    - cp "$PIPELINE_UTILS"/Dockerfile-react "$REACT_FOLDER"
    - cd "$REACT_FOLDER"
    - export IMAGE_NAME="$CI_REGISTRY_IMAGE/react:$DOCKER_TAG"
    - echo "Building $IMAGE_NAME"
    - docker buildx build --cache-from="$IMAGE_NAME" -t "$IMAGE_NAME" --push -f Dockerfile-react .
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_ID
      changes:
        - $REACT_FOLDER/**/*

# Generates an image of MSSQL and loads specified state from SQL file
# Runs on any change to SQL-file
build-db-image:
  <<: *build_image_template
  script:
    - cd "$PIPELINE_UTILS"
    - export IMAGE_NAME="$CI_REGISTRY_IMAGE/mssql-db:$DOCKER_TAG"
    # Main branch use prod init, MR use dev init
    - if [[ $CI_COMMIT_REF_NAME = $CI_DEFAULT_BRANCH ]]; then mv prod-db-init.sql db-init.sql; else mv dev-db-init.sql db-init.sql; fi
    - echo "Building $IMAGE_NAME"
    - docker buildx build --cache-from="$IMAGE_NAME" -t "$IMAGE_NAME" --push -f Dockerfile-db .
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
    - if: $CI_MERGE_REQUEST_ID
      changes:
        - $PIPELINE_UTILS/*.sql

# Build image containing python packages and script to deploy on Portainer
# ONLY build on when on main branch and any relevant files change
build-utils:
  <<: *build_image_template
  script:
    - cd "$PIPELINE_UTILS"
    - export IMAGE_NAME="$CI_REGISTRY_IMAGE/utils:latest"
    - echo "Building $IMAGE_NAME"
    - docker buildx build --cache-from="$IMAGE_NAME" -t "$IMAGE_NAME" --push -f Dockerfile-utils .
  rules:
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH
      changes:
        - $PIPELINE_UTILS/Dockerfile-utils
        - $PIPELINE_UTILS/requirements-api-handler.txt
        - $PIPELINE_UTILS/portainer.py

# Run all (fake) tests on codechange and ONLY on branches where there is a merge request
run-tests:
  stage: test
  script:
    - echo "TOTAL                  353     20    94%"
  coverage: '/TOTAL.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  rules:
    - if: $CI_MERGE_REQUEST_ID

# Setup for teardown and deploy
.base_util_setup:
  image: $CI_REGISTRY_IMAGE/utils:latest
  before_script:
    - export ENDPOINT_NAME="primary"
    - export CI_PROJECT_NAME=$(echo "$CI_PROJECT_NAME" | tr '[:upper:]' '[:lower:]')
    - export CI_COMMIT_REF_NAME=$(echo "$CI_COMMIT_REF_NAME" | tr '[:upper:]' '[:lower:]')
    - export STACK_NAME="g13-$CI_COMMIT_REF_SLUG"
    - cd "$PIPELINE_UTILS"
    - set -e

# Environment name reference
.environment_setup: &env_setup
  name: review/$CI_COMMIT_REF_NAME

deploy:
  extends: .base_util_setup
  stage: deploy
  environment:
    <<: *env_setup
    url: https://g13-$CI_COMMIT_REF_SLUG.cc25.chasacademy.dev
    on_stop: teardown
  script:
    - echo "Deploy"
    # Get correct composefile for main or testbranch
    - if [[ $CI_COMMIT_REF_NAME = $CI_DEFAULT_BRANCH ]]; then DOCKER_COMPOSE=docker-compose.yml; else DOCKER_COMPOSE=docker-compose-test.yml; fi
    - python portainer.py $CI_JOB_STAGE -dc $DOCKER_COMPOSE
  rules:
    - if: $CI_MERGE_REQUEST_ID
    - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH

teardown:
  extends: .base_util_setup
  stage: teardown
  image: $CI_REGISTRY_IMAGE/utils:latest
  environment:
    <<: *env_setup
    action: stop
  script:
    - echo "Teardown"
    - python portainer.py $CI_JOB_STAGE
  rules:
    - if: $CI_MERGE_REQUEST_ID
      when: manual

